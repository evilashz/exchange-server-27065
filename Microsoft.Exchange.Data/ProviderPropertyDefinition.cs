using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using Microsoft.Exchange.Collections;
using Microsoft.Exchange.Common;
using Microsoft.Exchange.Diagnostics;

namespace Microsoft.Exchange.Data
{
	// Token: 0x02000025 RID: 37
	[Serializable]
	internal abstract class ProviderPropertyDefinition : PropertyDefinition, IEquatable<ProviderPropertyDefinition>
	{
		// Token: 0x17000042 RID: 66
		// (get) Token: 0x06000131 RID: 305 RVA: 0x000055C7 File Offset: 0x000037C7
		public CustomFilterBuilderDelegate CustomFilterBuilderDelegate
		{
			get
			{
				return this.customFilterBuilderDelegate;
			}
		}

		// Token: 0x17000043 RID: 67
		// (get) Token: 0x06000132 RID: 306 RVA: 0x000055CF File Offset: 0x000037CF
		public object DefaultValue
		{
			get
			{
				return this.defaultValue;
			}
		}

		// Token: 0x17000044 RID: 68
		// (get) Token: 0x06000133 RID: 307 RVA: 0x000055D7 File Offset: 0x000037D7
		public ReadOnlyCollection<CollectionPropertyDefinitionConstraint> AllCollectionConstraints
		{
			get
			{
				return this.readOnlyAllCollectionConstraints;
			}
		}

		// Token: 0x17000045 RID: 69
		// (get) Token: 0x06000134 RID: 308 RVA: 0x000055DF File Offset: 0x000037DF
		public ReadOnlyCollection<CollectionPropertyDefinitionConstraint> ReadCollectionConstraints
		{
			get
			{
				return this.readOnlyReadCollectionConstraints;
			}
		}

		// Token: 0x17000046 RID: 70
		// (get) Token: 0x06000135 RID: 309 RVA: 0x000055E7 File Offset: 0x000037E7
		public ReadOnlyCollection<PropertyDefinitionConstraint> AllConstraints
		{
			get
			{
				return this.readOnlyAllConstraints;
			}
		}

		// Token: 0x17000047 RID: 71
		// (get) Token: 0x06000136 RID: 310 RVA: 0x000055EF File Offset: 0x000037EF
		public ReadOnlyCollection<PropertyDefinitionConstraint> ReadConstraints
		{
			get
			{
				return this.readOnlyReadConstraints;
			}
		}

		// Token: 0x17000048 RID: 72
		// (get) Token: 0x06000137 RID: 311 RVA: 0x000055F7 File Offset: 0x000037F7
		public ReadOnlyCollection<ProviderPropertyDefinition> SupportingProperties
		{
			get
			{
				return this.supportingProperties;
			}
		}

		// Token: 0x17000049 RID: 73
		// (get) Token: 0x06000138 RID: 312 RVA: 0x000055FF File Offset: 0x000037FF
		public ReadOnlyCollection<ProviderPropertyDefinition> DependentProperties
		{
			get
			{
				return this.readOnlyDependentProperties;
			}
		}

		// Token: 0x1700004A RID: 74
		// (get) Token: 0x06000139 RID: 313 RVA: 0x00005607 File Offset: 0x00003807
		public GetterDelegate GetterDelegate
		{
			get
			{
				return this.getterDelegate;
			}
		}

		// Token: 0x1700004B RID: 75
		// (get) Token: 0x0600013A RID: 314 RVA: 0x0000560F File Offset: 0x0000380F
		public SetterDelegate SetterDelegate
		{
			get
			{
				return this.setterDelegate;
			}
		}

		// Token: 0x1700004C RID: 76
		// (get) Token: 0x0600013B RID: 315 RVA: 0x00005617 File Offset: 0x00003817
		public ExchangeObjectVersion VersionAdded
		{
			get
			{
				return this.versionAdded;
			}
		}

		// Token: 0x1700004D RID: 77
		// (get) Token: 0x0600013C RID: 316 RVA: 0x0000561F File Offset: 0x0000381F
		public virtual bool IsFilterable
		{
			get
			{
				return !this.IsCalculated || null != this.CustomFilterBuilderDelegate;
			}
		}

		// Token: 0x1700004E RID: 78
		// (get) Token: 0x0600013D RID: 317 RVA: 0x00005637 File Offset: 0x00003837
		internal bool HasAutogeneratedConstraints
		{
			get
			{
				return this.hasAutogeneratedConstraints;
			}
		}

		// Token: 0x0600013E RID: 318 RVA: 0x0000563F File Offset: 0x0000383F
		public ProviderPropertyDefinition(string name, ExchangeObjectVersion versionAdded, Type type, object defaultValue) : this(name, versionAdded, type, defaultValue, PropertyDefinitionConstraint.None, PropertyDefinitionConstraint.None)
		{
		}

		// Token: 0x0600013F RID: 319 RVA: 0x00005658 File Offset: 0x00003858
		public ProviderPropertyDefinition(string name, ExchangeObjectVersion versionAdded, Type type, object defaultValue, PropertyDefinitionConstraint[] readConstraints, PropertyDefinitionConstraint[] writeConstraints) : this(name, versionAdded, type, defaultValue, readConstraints, writeConstraints, ProviderPropertyDefinition.None, null, null, null)
		{
		}

		// Token: 0x06000140 RID: 320 RVA: 0x0000567C File Offset: 0x0000387C
		public ProviderPropertyDefinition(string name, ExchangeObjectVersion versionAdded, Type type, object defaultValue, PropertyDefinitionConstraint[] readConstraints, PropertyDefinitionConstraint[] writeConstraints, ProviderPropertyDefinition[] supportingProperties, CustomFilterBuilderDelegate customFilterBuilderDelegate, GetterDelegate getterDelegate, SetterDelegate setterDelegate) : base(name, type)
		{
			if (supportingProperties == null)
			{
				throw new ArgumentNullException("supportingProperties");
			}
			if (readConstraints == null)
			{
				throw new ArgumentNullException("readConstraints");
			}
			if (writeConstraints == null)
			{
				throw new ArgumentNullException("writeConstraints");
			}
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (versionAdded == null)
			{
				throw new ArgumentNullException("versionAdded");
			}
			if (defaultValue != null && !ReflectionHelper.IsInstanceOfType(defaultValue, type))
			{
				throw new ArgumentException(DataStrings.ExceptionDefaultTypeMismatch.ToString(), "defaultValue (" + name + ")");
			}
			if (type == typeof(bool) && defaultValue != null)
			{
				defaultValue = BoxedConstants.GetBool((bool)defaultValue);
			}
			this.defaultValue = defaultValue;
			this.customFilterBuilderDelegate = customFilterBuilderDelegate;
			this.versionAdded = versionAdded;
			if (readConstraints.Length < 1)
			{
				this.readOnlyReadConstraints = ProviderPropertyDefinition.EmptyConstraint.Collection;
			}
			else
			{
				this.readOnlyReadConstraints = new ReadOnlyCollection<PropertyDefinitionConstraint>(readConstraints);
			}
			if (writeConstraints.Length < 1 && readConstraints.Length < 1)
			{
				this.allStaticConstraints = PropertyDefinitionConstraint.None;
				this.readOnlyAllConstraints = ProviderPropertyDefinition.EmptyConstraint.Collection;
			}
			else
			{
				this.allStaticConstraints = new PropertyDefinitionConstraint[readConstraints.Length + writeConstraints.Length];
				Array.Copy(writeConstraints, this.allStaticConstraints, writeConstraints.Length);
				Array.Copy(readConstraints, 0, this.allStaticConstraints, writeConstraints.Length, readConstraints.Length);
				this.readOnlyAllConstraints = new ReadOnlyCollection<PropertyDefinitionConstraint>(this.allStaticConstraints);
			}
			this.getterDelegate = getterDelegate;
			this.setterDelegate = setterDelegate;
			if (supportingProperties.Length < 1)
			{
				this.supportingProperties = ProviderPropertyDefinition.EmptyCollection;
			}
			else
			{
				this.supportingProperties = new ReadOnlyCollection<ProviderPropertyDefinition>(supportingProperties);
			}
			List<CollectionPropertyDefinitionConstraint> list = new List<CollectionPropertyDefinitionConstraint>();
			List<CollectionPropertyDefinitionConstraint> list2 = new List<CollectionPropertyDefinitionConstraint>();
			for (int i = 0; i < writeConstraints.Length; i++)
			{
				CollectionPropertyDefinitionConstraint collectionPropertyDefinitionConstraint = writeConstraints[i] as CollectionPropertyDefinitionConstraint;
				if (collectionPropertyDefinitionConstraint != null)
				{
					list.Add(collectionPropertyDefinitionConstraint);
				}
			}
			for (int j = 0; j < readConstraints.Length; j++)
			{
				CollectionPropertyDefinitionConstraint collectionPropertyDefinitionConstraint2 = readConstraints[j] as CollectionPropertyDefinitionConstraint;
				if (collectionPropertyDefinitionConstraint2 != null)
				{
					list.Add(collectionPropertyDefinitionConstraint2);
					list2.Add(collectionPropertyDefinitionConstraint2);
				}
			}
			if (list.Count < 1)
			{
				this.allStaticCollectionConstraints = ProviderPropertyDefinition.EmptyCollectionConstraint.Array;
				this.readOnlyAllCollectionConstraints = ProviderPropertyDefinition.EmptyCollectionConstraint.Collection;
			}
			else
			{
				this.allStaticCollectionConstraints = list.ToArray();
				this.readOnlyAllCollectionConstraints = new ReadOnlyCollection<CollectionPropertyDefinitionConstraint>(this.allStaticCollectionConstraints);
			}
			if (list2.Count < 1)
			{
				this.readOnlyReadCollectionConstraints = ProviderPropertyDefinition.EmptyCollectionConstraint.Collection;
			}
			else
			{
				this.readOnlyReadCollectionConstraints = new ReadOnlyCollection<CollectionPropertyDefinitionConstraint>(list2.ToArray());
			}
			this.readOnlyDependentProperties = ProviderPropertyDefinition.EmptyCollection;
			if (this.supportingProperties.Count == 0)
			{
				this.dependentProperties = new List<ProviderPropertyDefinition>();
			}
			foreach (ProviderPropertyDefinition providerPropertyDefinition in supportingProperties)
			{
				if (providerPropertyDefinition.IsCalculated)
				{
					throw new ArgumentException(string.Format("The calculated property '{0}' cannot depend on another calculated property '{1}'", base.Name, providerPropertyDefinition.Name), "supportingProperties");
				}
				if (this.VersionAdded.IsOlderThan(providerPropertyDefinition.VersionAdded))
				{
					throw new ArgumentException(string.Format("The calculated property '{0}' cannot depend on the newer property '{1}'", base.Name, providerPropertyDefinition.Name), "supportingProperties");
				}
				providerPropertyDefinition.AddDependency(this);
			}
			if (defaultValue != null && defaultValue != string.Empty)
			{
				PropertyValidationError propertyValidationError = this.ValidateValue(defaultValue, false);
				if (propertyValidationError != null)
				{
					throw new ArgumentException(propertyValidationError.Description, "defaultValue");
				}
			}
		}

		// Token: 0x06000141 RID: 321 RVA: 0x00005A00 File Offset: 0x00003C00
		internal void SetAutogeneratedConstraints(PropertyDefinitionConstraint[] autogeneratedConstraints)
		{
			if (autogeneratedConstraints == null)
			{
				throw new ArgumentNullException("autogeneratedConstraints");
			}
			PropertyDefinitionConstraint[] array;
			CollectionPropertyDefinitionConstraint[] list;
			if (autogeneratedConstraints.Length == 0)
			{
				array = this.allStaticConstraints;
				list = this.allStaticCollectionConstraints;
			}
			else
			{
				array = new PropertyDefinitionConstraint[this.allStaticConstraints.Length + autogeneratedConstraints.Length];
				Array.Copy(this.allStaticConstraints, array, this.allStaticConstraints.Length);
				Array.Copy(autogeneratedConstraints, 0, array, this.allStaticConstraints.Length, autogeneratedConstraints.Length);
				List<CollectionPropertyDefinitionConstraint> list2 = new List<CollectionPropertyDefinitionConstraint>(this.allStaticCollectionConstraints);
				for (int i = 0; i < autogeneratedConstraints.Length; i++)
				{
					CollectionPropertyDefinitionConstraint collectionPropertyDefinitionConstraint = autogeneratedConstraints[i] as CollectionPropertyDefinitionConstraint;
					if (collectionPropertyDefinitionConstraint != null)
					{
						list2.Add(collectionPropertyDefinitionConstraint);
					}
				}
				list = list2.ToArray();
			}
			lock (this.autogeneratedConstraintsSyncObject)
			{
				this.readOnlyAllConstraints = new ReadOnlyCollection<PropertyDefinitionConstraint>(array);
				this.readOnlyAllCollectionConstraints = new ReadOnlyCollection<CollectionPropertyDefinitionConstraint>(list);
				this.hasAutogeneratedConstraints = (0 != autogeneratedConstraints.Length);
			}
		}

		// Token: 0x06000142 RID: 322 RVA: 0x00005AF8 File Offset: 0x00003CF8
		[Conditional("DEBUG")]
		private void CheckConstraintConsistency(PropertyDefinitionConstraint[] staticConstraints, PropertyDefinitionConstraint[] autogeneratedConstraints)
		{
			for (int i = 0; i < autogeneratedConstraints.Length; i++)
			{
				Type type = autogeneratedConstraints[i].GetType();
				for (int j = 0; j < staticConstraints.Length; j++)
				{
					Type type2 = staticConstraints[j].GetType();
					if (type2 != type)
					{
						break;
					}
					if (typeof(StringLengthConstraint).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
					{
						StringLengthConstraint stringLengthConstraint = (StringLengthConstraint)autogeneratedConstraints[i];
						StringLengthConstraint stringLengthConstraint2 = (StringLengthConstraint)staticConstraints[j];
					}
					else if (typeof(ByteArrayLengthConstraint).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
					{
						ByteArrayLengthConstraint byteArrayLengthConstraint = (ByteArrayLengthConstraint)autogeneratedConstraints[i];
						ByteArrayLengthConstraint byteArrayLengthConstraint2 = (ByteArrayLengthConstraint)staticConstraints[j];
					}
					else if (typeof(RangedValueConstraint<ByteQuantifiedSize>).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
					{
						RangedValueConstraint<ByteQuantifiedSize> rangedValueConstraint = (RangedValueConstraint<ByteQuantifiedSize>)autogeneratedConstraints[i];
						RangedValueConstraint<ByteQuantifiedSize> rangedValueConstraint2 = (RangedValueConstraint<ByteQuantifiedSize>)staticConstraints[j];
					}
					else if (typeof(RangedValueConstraint<int>).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
					{
						RangedValueConstraint<int> rangedValueConstraint3 = (RangedValueConstraint<int>)autogeneratedConstraints[i];
						RangedValueConstraint<int> rangedValueConstraint4 = (RangedValueConstraint<int>)staticConstraints[j];
					}
					else if (typeof(RangedValueConstraint<long>).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
					{
						RangedValueConstraint<long> rangedValueConstraint5 = (RangedValueConstraint<long>)autogeneratedConstraints[i];
						RangedValueConstraint<long> rangedValueConstraint6 = (RangedValueConstraint<long>)staticConstraints[j];
					}
				}
			}
		}

		// Token: 0x06000143 RID: 323 RVA: 0x00005C40 File Offset: 0x00003E40
		private void AddDependency(ProviderPropertyDefinition dependentProperty)
		{
			lock (this.dependentPropertiesSyncObject)
			{
				this.dependentProperties.Add(dependentProperty);
				this.readOnlyDependentProperties = new ReadOnlyCollection<ProviderPropertyDefinition>(this.dependentProperties.ToArray());
			}
		}

		// Token: 0x06000144 RID: 324 RVA: 0x00005C9C File Offset: 0x00003E9C
		public virtual PropertyValidationError ValidateValue(object value, bool useOnlyReadConstraints)
		{
			return this.ValidateSingleValue(value, useOnlyReadConstraints, null);
		}

		// Token: 0x06000145 RID: 325 RVA: 0x00005CA7 File Offset: 0x00003EA7
		public PropertyValidationError ValidateCollection(IEnumerable collection, bool useOnlyReadConstraints)
		{
			return this.ValidateCollection(collection, useOnlyReadConstraints, null);
		}

		// Token: 0x06000146 RID: 326 RVA: 0x00005CB4 File Offset: 0x00003EB4
		public virtual IList<ValidationError> ValidateProperty(object value, IPropertyBag propertyBag, bool useOnlyReadConstraints)
		{
			List<ValidationError> list = new List<ValidationError>();
			if (value == null)
			{
				if (this.IsMandatory)
				{
					list.Add(new PropertyValidationError(DataStrings.PropertyIsMandatory, this, null));
				}
				return list;
			}
			if (this.IsMultivalued)
			{
				IEnumerable enumerable = value as IEnumerable;
				if (enumerable == null)
				{
					list.Add(new PropertyValidationError(DataStrings.PropertyNotACollection(value.GetType().Name), this, value));
					return list;
				}
				int num = 0;
				foreach (object value2 in enumerable)
				{
					num++;
					PropertyValidationError propertyValidationError = this.ValidateSingleValue(value2, useOnlyReadConstraints, propertyBag);
					if (propertyValidationError != null)
					{
						list.Add(propertyValidationError);
					}
				}
				if (num == 0 && this.IsMandatory)
				{
					list.Add(new PropertyValidationError(DataStrings.PropertyIsMandatory, this, null));
				}
				PropertyValidationError propertyValidationError2 = this.ValidateCollection(enumerable, useOnlyReadConstraints, propertyBag);
				if (propertyValidationError2 != null)
				{
					list.Add(propertyValidationError2);
				}
			}
			else
			{
				PropertyValidationError propertyValidationError3 = this.ValidateSingleValue(value, useOnlyReadConstraints, propertyBag);
				if (propertyValidationError3 != null)
				{
					list.Add(propertyValidationError3);
				}
			}
			return list;
		}

		// Token: 0x06000147 RID: 327 RVA: 0x00005DC8 File Offset: 0x00003FC8
		private PropertyValidationError ValidateCollection(IEnumerable collection, bool useOnlyReadConstraints, IPropertyBag propertyBag)
		{
			ReadOnlyCollection<CollectionPropertyDefinitionConstraint> readOnlyCollection = useOnlyReadConstraints ? this.readOnlyReadCollectionConstraints : this.readOnlyAllCollectionConstraints;
			int count = readOnlyCollection.Count;
			for (int i = 0; i < count; i++)
			{
				PropertyValidationError propertyValidationError = readOnlyCollection[i].Validate(collection, this, propertyBag);
				if (propertyValidationError != null)
				{
					return propertyValidationError;
				}
			}
			return null;
		}

		// Token: 0x06000148 RID: 328 RVA: 0x00005E10 File Offset: 0x00004010
		private PropertyValidationError ValidateSingleValue(object value, bool useOnlyReadConstraints, IPropertyBag propertyBag)
		{
			if (this.IsMandatory)
			{
				if (value == null)
				{
					return new PropertyValidationError(DataStrings.PropertyIsMandatory, this, null);
				}
				if (value.GetType() == typeof(string) && value.ToString().Length == 0)
				{
					return new PropertyValidationError(DataStrings.PropertyIsMandatory, this, value);
				}
			}
			if (value != null && !ReflectionHelper.IsInstanceOfType(value, base.Type))
			{
				return new PropertyValidationError(DataStrings.PropertyTypeMismatch(value.GetType().FullName, base.Type.FullName), this, value);
			}
			ReadOnlyCollection<PropertyDefinitionConstraint> readOnlyCollection = useOnlyReadConstraints ? this.readOnlyReadConstraints : this.readOnlyAllConstraints;
			int count = readOnlyCollection.Count;
			for (int i = 0; i < count; i++)
			{
				PropertyDefinitionConstraint propertyDefinitionConstraint = readOnlyCollection[i];
				if (!(propertyDefinitionConstraint is CollectionPropertyDefinitionConstraint))
				{
					PropertyValidationError propertyValidationError = propertyDefinitionConstraint.Validate(value, this, propertyBag);
					if (propertyValidationError != null)
					{
						return propertyValidationError;
					}
				}
			}
			return null;
		}

		// Token: 0x1700004F RID: 79
		// (get) Token: 0x06000149 RID: 329
		public abstract bool IsMultivalued { get; }

		// Token: 0x17000050 RID: 80
		// (get) Token: 0x0600014A RID: 330
		public abstract bool IsReadOnly { get; }

		// Token: 0x17000051 RID: 81
		// (get) Token: 0x0600014B RID: 331
		public abstract bool IsCalculated { get; }

		// Token: 0x17000052 RID: 82
		// (get) Token: 0x0600014C RID: 332
		public abstract bool IsFilterOnly { get; }

		// Token: 0x17000053 RID: 83
		// (get) Token: 0x0600014D RID: 333
		public abstract bool IsMandatory { get; }

		// Token: 0x17000054 RID: 84
		// (get) Token: 0x0600014E RID: 334
		public abstract bool PersistDefaultValue { get; }

		// Token: 0x17000055 RID: 85
		// (get) Token: 0x0600014F RID: 335
		public abstract bool IsWriteOnce { get; }

		// Token: 0x17000056 RID: 86
		// (get) Token: 0x06000150 RID: 336
		public abstract bool IsBinary { get; }

		// Token: 0x17000057 RID: 87
		// (get) Token: 0x06000151 RID: 337 RVA: 0x00005EE2 File Offset: 0x000040E2
		public virtual bool IsTaskPopulated
		{
			get
			{
				return false;
			}
		}

		// Token: 0x06000152 RID: 338 RVA: 0x00005EE5 File Offset: 0x000040E5
		public override bool Equals(object obj)
		{
			return this.Equals(obj as ProviderPropertyDefinition);
		}

		// Token: 0x06000153 RID: 339 RVA: 0x00005EF3 File Offset: 0x000040F3
		public override int GetHashCode()
		{
			if (this.hashcode == 0)
			{
				this.hashcode = base.Name.ToLower().GetHashCode();
			}
			return this.hashcode;
		}

		// Token: 0x06000154 RID: 340 RVA: 0x00005F19 File Offset: 0x00004119
		public override string ToString()
		{
			return string.Format("{0} ({1})", base.Name, base.Type);
		}

		// Token: 0x06000155 RID: 341 RVA: 0x00005F34 File Offset: 0x00004134
		public virtual bool Equals(ProviderPropertyDefinition other)
		{
			return other != null && (object.ReferenceEquals(other, this) || (!this.IsCalculated && StringComparer.OrdinalIgnoreCase.Equals(other.Name, base.Name) && !(other.Type != base.Type) && !(other.GetType() != base.GetType())));
		}

		// Token: 0x04000060 RID: 96
		public static ProviderPropertyDefinition[] None = new ProviderPropertyDefinition[0];

		// Token: 0x04000061 RID: 97
		private static readonly ReadOnlyCollection<ProviderPropertyDefinition> EmptyCollection = new ReadOnlyCollection<ProviderPropertyDefinition>(ProviderPropertyDefinition.None);

		// Token: 0x04000062 RID: 98
		private static readonly ProviderPropertyDefinition.Empty<CollectionPropertyDefinitionConstraint> EmptyCollectionConstraint = new ProviderPropertyDefinition.Empty<CollectionPropertyDefinitionConstraint>();

		// Token: 0x04000063 RID: 99
		private static readonly ProviderPropertyDefinition.Empty<PropertyDefinitionConstraint> EmptyConstraint = new ProviderPropertyDefinition.Empty<PropertyDefinitionConstraint>();

		// Token: 0x04000064 RID: 100
		[NonSerialized]
		private readonly object dependentPropertiesSyncObject = new object();

		// Token: 0x04000065 RID: 101
		[NonSerialized]
		protected int hashcode;

		// Token: 0x04000066 RID: 102
		[NonSerialized]
		private ExchangeObjectVersion versionAdded;

		// Token: 0x04000067 RID: 103
		[NonSerialized]
		private object defaultValue;

		// Token: 0x04000068 RID: 104
		[NonSerialized]
		private PropertyDefinitionConstraint[] allStaticConstraints;

		// Token: 0x04000069 RID: 105
		[NonSerialized]
		private CollectionPropertyDefinitionConstraint[] allStaticCollectionConstraints;

		// Token: 0x0400006A RID: 106
		[NonSerialized]
		private ReadOnlyCollection<PropertyDefinitionConstraint> readOnlyReadConstraints;

		// Token: 0x0400006B RID: 107
		[NonSerialized]
		private ReadOnlyCollection<PropertyDefinitionConstraint> readOnlyAllConstraints;

		// Token: 0x0400006C RID: 108
		[NonSerialized]
		private ReadOnlyCollection<CollectionPropertyDefinitionConstraint> readOnlyReadCollectionConstraints;

		// Token: 0x0400006D RID: 109
		[NonSerialized]
		private ReadOnlyCollection<CollectionPropertyDefinitionConstraint> readOnlyAllCollectionConstraints;

		// Token: 0x0400006E RID: 110
		[NonSerialized]
		private CustomFilterBuilderDelegate customFilterBuilderDelegate;

		// Token: 0x0400006F RID: 111
		[NonSerialized]
		private GetterDelegate getterDelegate;

		// Token: 0x04000070 RID: 112
		[NonSerialized]
		private SetterDelegate setterDelegate;

		// Token: 0x04000071 RID: 113
		[NonSerialized]
		private ReadOnlyCollection<ProviderPropertyDefinition> supportingProperties;

		// Token: 0x04000072 RID: 114
		[NonSerialized]
		private ReadOnlyCollection<ProviderPropertyDefinition> readOnlyDependentProperties;

		// Token: 0x04000073 RID: 115
		[NonSerialized]
		private List<ProviderPropertyDefinition> dependentProperties;

		// Token: 0x04000074 RID: 116
		[NonSerialized]
		private bool hasAutogeneratedConstraints;

		// Token: 0x04000075 RID: 117
		[NonSerialized]
		private object autogeneratedConstraintsSyncObject = new object();

		// Token: 0x02000026 RID: 38
		private class Empty<T>
		{
			// Token: 0x06000157 RID: 343 RVA: 0x00005FCA File Offset: 0x000041CA
			public Empty()
			{
				this.Array = new T[0];
				this.Collection = new ReadOnlyCollection<T>(this.Array);
			}

			// Token: 0x04000076 RID: 118
			public readonly T[] Array;

			// Token: 0x04000077 RID: 119
			public readonly ReadOnlyCollection<T> Collection;
		}
	}
}
