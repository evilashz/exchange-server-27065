using System;
using System.Collections.Generic;
using Microsoft.Exchange.Data.Directory;
using Microsoft.Exchange.Data.Directory.SystemConfiguration;
using Microsoft.Exchange.Diagnostics.Components.MalwareAgent;
using Microsoft.Exchange.Transport.Agent.Malware.Common;
using Microsoft.Office.Datacenter.ActiveMonitoring;

namespace Microsoft.Exchange.Transport.Agent.Malware
{
	// Token: 0x02000036 RID: 54
	internal class TenantMalwareFilterPolicies : TenantConfigurationCacheableItem<MalwareFilterPolicy>
	{
		// Token: 0x1700004D RID: 77
		// (get) Token: 0x06000143 RID: 323 RVA: 0x00009BDC File Offset: 0x00007DDC
		public override long ItemSize
		{
			get
			{
				return this.estimatedSize + 8L;
			}
		}

		// Token: 0x1700004E RID: 78
		// (get) Token: 0x06000144 RID: 324 RVA: 0x00009BE7 File Offset: 0x00007DE7
		public int Count
		{
			get
			{
				return this.malwareFilterPolicies.Count;
			}
		}

		// Token: 0x06000145 RID: 325 RVA: 0x00009BF4 File Offset: 0x00007DF4
		public override void ReadData(IConfigurationSession tenantConfigurationSession)
		{
			ADObjectId childId = tenantConfigurationSession.GetOrgContainerId().GetChildId("Transport Settings").GetChildId("Malware Filter");
			IEnumerable<MalwareFilterPolicy> enumerable = tenantConfigurationSession.FindPaged<MalwareFilterPolicy>(childId, QueryScope.OneLevel, null, null, 0, null);
			this.estimatedSize = 0L;
			if (enumerable != null)
			{
				this.malwareFilterPolicies = new Dictionary<string, MalwareFilterPolicy>(StringComparer.InvariantCultureIgnoreCase);
				foreach (MalwareFilterPolicy malwareFilterPolicy in enumerable)
				{
					if (malwareFilterPolicy.IsConflicted())
					{
						string text = string.Format("Malware Filter policy with name '{0}', distinguished name '{1}' is a conflicted object and is being ignored for Organization ID '{2}'.", malwareFilterPolicy.Name, malwareFilterPolicy.DistinguishedName, base.OrganizationId);
						MalwareAgentGlobal.EventLogger.LogEvent(AntimalwareEventLogConstants.Tuple_TenantConfigurationError, base.OrganizationId.ToString(), new object[]
						{
							base.OrganizationId,
							text
						});
					}
					else if (!this.malwareFilterPolicies.ContainsKey(malwareFilterPolicy.Name))
					{
						this.malwareFilterPolicies.Add(malwareFilterPolicy.Name, malwareFilterPolicy);
						this.estimatedSize += (long)(malwareFilterPolicy.Name.Length * 2) + malwareFilterPolicy.GetEstimatedSize();
						if (malwareFilterPolicy.IsDefault)
						{
							this.defaultPolicyName = malwareFilterPolicy.Name;
							this.estimatedSize += (long)(malwareFilterPolicy.Name.Length * 2);
						}
					}
					else
					{
						string text2 = string.Format("Malware Filter policy with name '{0}', distinguished name '{1}' already exists for Organization ID '{2}'.", malwareFilterPolicy.Name, malwareFilterPolicy.DistinguishedName, base.OrganizationId);
						EventNotificationItem.Publish(ExchangeComponent.AMTenantConfigError.Name, "AntimalwareAgent.TenantConfigurationError", null, text2, ResultSeverityLevel.Error, false);
						ExTraceGlobals.AgentTracer.TraceError((long)this.GetHashCode(), text2);
					}
				}
			}
		}

		// Token: 0x06000146 RID: 326 RVA: 0x00009DB4 File Offset: 0x00007FB4
		public bool GetMalwareFilterPolicyByName(string policyName, out MalwareFilterPolicy policy)
		{
			policy = null;
			return policyName != null && this.malwareFilterPolicies != null && this.malwareFilterPolicies.TryGetValue(policyName, out policy);
		}

		// Token: 0x06000147 RID: 327 RVA: 0x00009DD5 File Offset: 0x00007FD5
		public bool GetDefaultMalwareFilterPolicy(out MalwareFilterPolicy policy)
		{
			return this.GetMalwareFilterPolicyByName(this.defaultPolicyName, out policy);
		}

		// Token: 0x04000143 RID: 323
		private Dictionary<string, MalwareFilterPolicy> malwareFilterPolicies;

		// Token: 0x04000144 RID: 324
		private string defaultPolicyName;

		// Token: 0x04000145 RID: 325
		private long estimatedSize;
	}
}
