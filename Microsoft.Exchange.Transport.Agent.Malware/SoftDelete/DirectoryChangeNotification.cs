using System;
using System.IO;
using System.Threading;
using System.Timers;

namespace Microsoft.Exchange.Transport.Agent.Malware.SoftDelete
{
	// Token: 0x02000013 RID: 19
	internal class DirectoryChangeNotification : IDisposable
	{
		// Token: 0x06000047 RID: 71 RVA: 0x000040B6 File Offset: 0x000022B6
		public DirectoryChangeNotification(CalculationAsync calculationAsysnc)
		{
			if (calculationAsysnc == null)
			{
				throw new ArgumentNullException("CalculationAsync object must be specified.");
			}
			this.calculationAsync = calculationAsysnc;
			this.directory = this.calculationAsync.SoftDeleteQueue.Storage.GetStorageDestination();
		}

		// Token: 0x06000048 RID: 72 RVA: 0x000040EE File Offset: 0x000022EE
		public void Dispose()
		{
			if (this.fsw != null)
			{
				this.fsw.Dispose();
				this.fsw = null;
			}
			if (this.timer != null)
			{
				this.timer.Dispose();
				this.timer = null;
			}
		}

		// Token: 0x06000049 RID: 73 RVA: 0x00004124 File Offset: 0x00002324
		public void Run()
		{
			if (!Directory.Exists(this.directory))
			{
				throw new StorageException("FileWatcher cannot be installed on a directory that does not exist.");
			}
			this.fsw = new FileSystemWatcher();
			this.fsw.Path = this.directory;
			this.fsw.NotifyFilter = (NotifyFilters.FileName | NotifyFilters.Size | NotifyFilters.LastWrite | NotifyFilters.LastAccess);
			this.fsw.Filter = "*.frf";
			this.fsw.Deleted += this.OnChanged;
			this.fsw.IncludeSubdirectories = true;
			this.fsw.EnableRaisingEvents = true;
			this.timer = new System.Timers.Timer(10000.0);
			this.timer.AutoReset = false;
			this.timer.Elapsed += this.TimerElapsed;
		}

		// Token: 0x0600004A RID: 74 RVA: 0x000041E8 File Offset: 0x000023E8
		private void OnChanged(object source, FileSystemEventArgs e)
		{
			this.timer.Enabled = true;
		}

		// Token: 0x0600004B RID: 75 RVA: 0x000041F8 File Offset: 0x000023F8
		private void TimerElapsed(object source, ElapsedEventArgs e)
		{
			try
			{
				DirectoryChangeNotification.mutex.WaitOne();
				this.timer.Stop();
				IAsyncResult calcAsyncResult = this.calculationAsync.BeginCalculation(null, null);
				long num = this.calculationAsync.EndCalculation(calcAsyncResult);
				DirectoryStorage directoryStorage = this.calculationAsync.SoftDeleteQueue.Storage as DirectoryStorage;
				if (directoryStorage != null)
				{
					directoryStorage.CurrentDirectorySize = num;
					directoryStorage.PerfCounterWrapper.UpdateRecoveryStoreSize(num, directoryStorage.MaxThreshold, true);
				}
			}
			finally
			{
				DirectoryChangeNotification.mutex.ReleaseMutex();
			}
		}

		// Token: 0x04000041 RID: 65
		private static Mutex mutex = new Mutex();

		// Token: 0x04000042 RID: 66
		private readonly string directory;

		// Token: 0x04000043 RID: 67
		private CalculationAsync calculationAsync;

		// Token: 0x04000044 RID: 68
		private System.Timers.Timer timer;

		// Token: 0x04000045 RID: 69
		private FileSystemWatcher fsw;
	}
}
